const { app, BrowserWindow, ipcMain, Menu, shell } = require("electron");
const path = require("path");
const fs = require("fs");
const https = require("https");
const http = require("http"); // âœ… Import HTTP for local downloads
const { pipeline } = require("stream");
const { promisify } = require("util");
const StreamZip = require("extract-zip");
const AdmZip = require("adm-zip");
const gotTheLock = app.requestSingleInstanceLock();

const LOCAL_HTML_PATH = path.join(app.getPath("userData"), "index.html");
const DEFAULT_HTML_PATH = path.join(__dirname, "index.html"); 
const PDF_FOLDER_PATH = path.join(app.getPath("documents"), "Service Manuals", "PDF");
const ZIP_DOWNLOAD_PATH = path.join(app.getPath("userData"), "servicemanual.zip");
const REMOTE_HTML_URL = "https://raw.githubusercontent.com/sdfsafasf/Service-Manual/main/index.html";
const DROPBOX_ZIP_URL = "http://localhost:3000/servicemanual.zip";
const LOG_FILE_PATH = path.join(app.getPath("userData"), "update-log.txt");

let mainWindow, downloadWindow;

// âœ… Function to log all activities
function logUpdate(message) {
    const logEntry = `${new Date().toISOString()} - ${message}\n`;
    fs.appendFileSync(LOG_FILE_PATH, logEntry);
    console.log(message);
}

// âœ… Ensure index.html is copied if missing
function ensureIndexHtmlExists() {
    if (!fs.existsSync(LOCAL_HTML_PATH)) {
        if (fs.existsSync(DEFAULT_HTML_PATH)) {
            fs.copyFileSync(DEFAULT_HTML_PATH, LOCAL_HTML_PATH);
            logUpdate("ðŸ“‚ index.html copied to AppData.");
        } else {
            logUpdate("âŒ ERROR: index.html is missing from the application directory.");
        }
    }
}


// âœ… Function to Get List of PDFs
function getPdfFiles() {
    if (!fs.existsSync(PDF_FOLDER_PATH)) {
        return []; // If folder doesn't exist, return empty array
    }

    return fs.readdirSync(PDF_FOLDER_PATH)
        .filter(file => file.endsWith(".pdf")) // âœ… Only include PDF files
        .map(file => ({
            name: file,
            path: `file://${path.join(PDF_FOLDER_PATH, file)}` // âœ… Convert to file URL
        }));
}




// âœ… Handle Local PDF Links from `index.html`

ipcMain.handle("resolve-pdf-path", async (event, relativePath) => {
    // âœ… Remove any incorrect "file://" prefixes
    relativePath = relativePath.replace(/^file:\/\//, "");

    // âœ… Ensure only relative paths are used
    if (path.isAbsolute(relativePath)) {
        relativePath = path.relative(app.getPath("documents"), relativePath);
    }

    const fullPath = path.join(PDF_FOLDER_PATH, relativePath);

    // âœ… Remove excessive logging to prevent console spam
    console.log(`âœ… Resolved PDF Path: ${fullPath}`);

    return fullPath;
});

ipcMain.on("open-pdf", (event, pdfPath) => {
    openPdfWindow(pdfPath);
});



// âœ… Handle Request from Renderer for PDF List
ipcMain.handle("get-pdf-files", async () => {
    return getPdfFiles();
});



// âœ… Ensure PDF folder exists
function ensurePdfFolderExists() {
    if (!fs.existsSync(PDF_FOLDER_PATH)) {
        fs.mkdirSync(PDF_FOLDER_PATH, { recursive: true });
        logUpdate("ðŸ“‚ Created PDFs folder in Documents.");
    }
}


let pdfWindow = null; // âœ… Ensure only ONE instance exists

function openPdfWindow(pdfRelativePath) {
    // âœ… If the PDF window already exists, focus on it instead of opening a new one
    if (pdfWindow) {
        if (!pdfWindow.isDestroyed()) {
            pdfWindow.focus();
            return;
        } else {
            pdfWindow = null; // âœ… Reset if the window was destroyed
        }
    }

    // âœ… Remove "file://" if mistakenly added
    pdfRelativePath = pdfRelativePath.replace(/^file:\/\//, "");

    // âœ… Fix doubled paths by extracting only the actual filename
    if (pdfRelativePath.includes("C:\\Users")) {
        const parts = pdfRelativePath.split("Service Manuals\\PDF\\");
        pdfRelativePath = parts[parts.length - 1]; // âœ… Get only the last valid part
    }

    const pdfFullPath = path.join(PDF_FOLDER_PATH, pdfRelativePath);

    console.log(`ðŸ” Trying to Open PDF: ${pdfFullPath}`); // âœ… Debugging

    // âœ… Ensure the file exists before opening
    if (!fs.existsSync(pdfFullPath)) {
        console.error(`âŒ PDF not found: ${pdfFullPath}`);
        return;
    }

    // âœ… Create a SINGLE maximized PDF window
    pdfWindow = new BrowserWindow({
        show: false,
        icon: path.join(__dirname, "assets", "icon.ico"),
        autoHideMenuBar: true,
        webPreferences: {
            nodeIntegration: false,
        },
    });

    pdfWindow.loadFile(pdfFullPath);

    pdfWindow.once("ready-to-show", () => {
        pdfWindow.maximize(); // âœ… Maximizes BEFORE showing
        pdfWindow.show();
    });

    pdfWindow.on("closed", () => {
        pdfWindow = null; // âœ… Ensure the window is removed when closed
    });
}

function logUpdate(message) {
    const logFilePath = path.join(app.getPath("userData"), "app-log.txt");
    const logEntry = `${new Date().toISOString()} - ${message}\n`;
    fs.appendFileSync(logFilePath, logEntry);
    console.log(message); // âœ… Also logs to the console
}





// âœ… Check for Updates
async function checkForUpdates() {
    logUpdate("ðŸ” Checking for updates from GitHub..."); // âœ… Log at the start

    return new Promise((resolve, reject) => {
        https.get(REMOTE_HTML_URL, (res) => {
            if (res.statusCode !== 200) {
                logUpdate(`âŒ Failed to fetch update. Status Code: ${res.statusCode}`);
                reject();
                return;
            }

            let newContent = "";
            res.on("data", (chunk) => { newContent += chunk; });
            res.on("end", () => {
                let oldContent = fs.existsSync(LOCAL_HTML_PATH) ? fs.readFileSync(LOCAL_HTML_PATH, "utf8") : "";

                if (oldContent !== newContent) {
                    fs.writeFileSync(LOCAL_HTML_PATH, newContent, "utf8");
                    logUpdate("âœ… New update downloaded and applied.");
                    resolve(true);
                } else {
                    logUpdate("âœ… No update needed. The latest version is already installed.");
                    resolve(false);
                }
            });
        }).on("error", (err) => {
            logUpdate(`âŒ Update check failed: ${err.message}`);
            reject();
        });
    });
}

// âœ… Run update checks every 5 minutes
setInterval(async () => {
    try {
        let updated = await checkForUpdates();
        if (updated) {
            logUpdate("ðŸ”„ Update detected. Reloading...");
            mainWindow.webContents.reload(); // âœ… Reload the page if an update is found
        }
    } catch (error) {
        logUpdate(`âŒ Error checking for updates: ${error.message}`);
    }
}, 5 * 60 * 1000); // âœ… Check every 5 minutes

app.whenReady().then(async () => {
    await checkForUpdates(); // âœ… Check for updates immediately on startup
    createMainWindow();
});

if (!gotTheLock) {
    app.quit();
} else {
    app.on("second-instance", () => {
        if (mainWindow) {
            if (mainWindow.isMinimized()) mainWindow.restore();
            mainWindow.focus();
        }
    });

    app.whenReady().then(() => {
        createMainWindow();
    });

    app.on("window-all-closed", () => {
        if (process.platform !== "darwin") {
            app.quit();
        }
    });

    app.on("activate", () => {
        if (BrowserWindow.getAllWindows().length === 0) {
            createMainWindow();
        }
    });
}



async function createMainWindow() {
    if (mainWindow) return; // Prevents duplicate window creation

    ensureIndexHtmlExists();
    ensurePdfFolderExists();

    mainWindow = new BrowserWindow({
        show: false,
        width: 1024,
        height: 768,
        resizable: true,
        frame: false, // Custom title bar (no native window frame)
        transparent: true, // Optional if you want transparency
        titleBarStyle: 'hidden', // Hide native title bar
        icon: path.join(__dirname, "assets", "icon.ico"),
		        icon: path.join(__dirname, "assets", "icon.png"),
        backgroundColor: "#282828",  // Keeps the dark background
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
            preload: path.join(__dirname, "preload.js"),
            devTools: false, // Disables DevTools (F12)
        },
    });
    // Explicitly set the icon after window creation
	
    mainWindow.setIcon(path.join(__dirname, 'assets', 'icon.png'));
    // Show the window when it's ready
    mainWindow.once("ready-to-show", () => {
        mainWindow.maximize();  // Maximize on startup
        mainWindow.show();
    });

    // Load the local HTML file
    if (fs.existsSync(LOCAL_HTML_PATH)) {
        mainWindow.loadURL(`file://${LOCAL_HTML_PATH}`);
    } else {
        logUpdate("âŒ ERROR: index.html missing in AppData!");
    }

    mainWindow.on("closed", () => {
        mainWindow = null;
    });

    // Handle opening new windows (e.g., PDFs)
    mainWindow.webContents.on("new-window", (event, url) => {
        if (url.endsWith(".pdf")) {
            event.preventDefault();
            shell.openExternal(url); // Opens PDFs in system viewer
        }
    });

    mainWindow.webContents.setWindowOpenHandler(({ url }) => {
        if (url.endsWith(".pdf")) {
            openPdfWindow(url); // Opens PDFs properly
            return { action: "deny" }; // Prevents default blank window
        }
        return { action: "allow" };
    });

    // Handle IPC events for window controls
    ipcMain.on('minimize-window', () => {
        mainWindow.minimize();
    });

    ipcMain.on('maximize-window', () => {
        if (mainWindow.isMaximized()) {
            mainWindow.restore();
        } else {
            mainWindow.maximize();
        }
    });

    ipcMain.on('close-window', () => {
        mainWindow.close(); // Close the window when the event is triggered
    });
}



ipcMain.on("restart-app", () => {
    app.relaunch();  // âœ… Relaunches the app
    app.exit(0);      // âœ… Closes current instance
});

// âœ… Create Separate Download Window
function createDownloadWindow() {
    console.log("ðŸŸ¢ Creating download window...");

    downloadWindow = new BrowserWindow({
        width: 600,
        height: 300,
        resizable: false,
        alwaysOnTop: false,
        transparent: true,
        titleBarStyle: 'hidden', // âœ… Hides default title bar but keeps custom styling
        modal: true,
        icon: path.join(__dirname, "assets", "icon.ico"),
        parent: mainWindow,
        frame: false, // âœ… Removes window controls for download window ONLY
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
            preload: path.join(__dirname, "preload.js"),
        },
    });

    // Disable the maximize behavior on double-click
    downloadWindow.setResizable(true);
    downloadWindow.setMaximizable(false);  // Disables maximize functionality

    console.log("ðŸ“‚ Loading download.html...");
    downloadWindow.loadFile("download.html").then(() => {
        console.log("âœ… Download window loaded successfully!");
    }).catch(err => {
        console.error("âŒ Failed to load download.html:", err);
    });

    // Listen for focus and blur events after window creation
    downloadWindow.on('focus', () => {
        downloadWindow.webContents.send('window-focus');
    });

    downloadWindow.on('blur', () => {
        downloadWindow.webContents.send('window-blur');
    });
}





// âœ… Function to Extract the ZIP (No Nested ZIP Handling Needed)
async function extractZip(filePath, destination) {
    logUpdate(`ðŸ“‚ Extracting ZIP: ${filePath} -> ${destination}`);

    const zip = new StreamZip.async({ file: filePath });
    await zip.extract(null, destination); // âœ… Extracts the entire structure
    await zip.close();

    logUpdate(`âœ… Extracted: ${filePath}`);
}

async function downloadAndExtractPdfs() {
    console.log("ðŸ”½ Starting PDF download...");

    return new Promise((resolve, reject) => {
        let DOWNLOAD_URL = "http://localhost:3000/servicemanual.zip";
        const protocol = DOWNLOAD_URL.startsWith("https") ? https : http;

        console.log(`ðŸŒŽ Fetching ZIP from: ${DOWNLOAD_URL}`);

        const request = protocol.get(DOWNLOAD_URL, (res) => {
            if (res.statusCode !== 200) {
                console.error(`âŒ Failed to download ZIP. HTTP Status: ${res.statusCode}`);
                reject(new Error(`HTTP Status ${res.statusCode}`));
                return;
            }

            const fileStream = fs.createWriteStream(ZIP_DOWNLOAD_PATH);
            let totalSize = parseInt(res.headers["content-length"], 10);
            let downloadedSize = 0;
            let startTime = Date.now();

            console.log(`ðŸ” Downloading ZIP file... Estimated Size: ${totalSize} bytes`);

            res.on("data", (chunk) => {
                downloadedSize += chunk.length;
                const progress = totalSize ? (downloadedSize / totalSize) * 100 : 0;
                let elapsedTime = (Date.now() - startTime) / 1000;
                let speed = downloadedSize / elapsedTime;
                let timeRemaining = speed > 0 ? ((totalSize - downloadedSize) / speed).toFixed(0) : "Calculating...";

                const downloadedMB = (downloadedSize / 1024 / 1024).toFixed(2);
                const totalMB = totalSize ? (totalSize / 1024 / 1024).toFixed(2) : "Unknown";

                if (downloadWindow && !downloadWindow.isDestroyed()) {
                    downloadWindow.webContents.send("download-progress", Math.round(progress), downloadedMB, totalMB, timeRemaining);
                }
            });

            fileStream.on("finish", async () => {
                console.log("âœ… ZIP file downloaded successfully.");
                if (downloadWindow && !downloadWindow.isDestroyed()) {
                    downloadWindow.webContents.send("download-complete");
                }

                console.log(`ðŸ“‚ Extracting ZIP to: ${PDF_FOLDER_PATH}`);
                await extractZipFile(ZIP_DOWNLOAD_PATH, PDF_FOLDER_PATH);
                resolve();
            });

            request.on("error", (err) => {
                console.error(`âŒ Download failed: ${err.message}`);
                reject(err);
            });

            res.pipe(fileStream);
        });
    });
}

async function extractZipFile(zipPath, extractTo) {
    try {
        console.log("â³ Extraction process is starting...");

        // âœ… Ensure extraction folder exists
        if (!fs.existsSync(extractTo)) {
            fs.mkdirSync(extractTo, { recursive: true });
        }

        // âœ… Get the list of files in the ZIP before extracting
        const AdmZip = require("adm-zip"); // Use adm-zip to get file list
        const zip = new AdmZip(zipPath);
        const zipEntries = zip.getEntries();
        const totalFiles = zipEntries.length;
        let extractedFiles = 0;
        let startTime = Date.now();

        console.log(`ðŸ“‚ Total files to extract: ${totalFiles}`);

        // âœ… Extract file-by-file to update progress
        for (const entry of zipEntries) {
            if (!entry.isDirectory) {
                const entryPath = path.join(extractTo, entry.entryName);
                
                // Ensure directories exist before extracting the file
                fs.mkdirSync(path.dirname(entryPath), { recursive: true });

                // Write file contents to disk
                fs.writeFileSync(entryPath, zip.readFile(entry));

                extractedFiles++;

                let extractProgress = (extractedFiles / totalFiles) * 100;
                let elapsedTime = (Date.now() - startTime) / 1000; // seconds
                let avgTimePerFile = elapsedTime / extractedFiles;
                let estimatedTimeRemaining = Math.max(0, ((totalFiles - extractedFiles) * avgTimePerFile).toFixed(0));

                // âœ… Send progress updates to the renderer process
                if (downloadWindow && !downloadWindow.isDestroyed()) {
                    downloadWindow.webContents.send("extract-progress", Math.round(extractProgress), estimatedTimeRemaining);
                }

                console.log(`âœ… Extracted ${extractedFiles}/${totalFiles} - ${extractProgress.toFixed(2)}%`);
            }
        }

        // âœ… Cleanup ZIP after extraction
        fs.unlinkSync(zipPath);
        console.log("ðŸŽ‰ Extraction complete!");

        // âœ… Notify UI that extraction is done
        if (downloadWindow && !downloadWindow.isDestroyed()) {
            downloadWindow.webContents.send("extract-complete");
        }

    } catch (error) {
        console.error("âŒ Extraction failed:", error);
    }
}






















// âœ… Listen for Download Requests from HTML
ipcMain.on("start-download", async () => {
    await downloadAndExtractPdfs();
});

// âœ… Close Download Window When User Clicks "OK"
ipcMain.on("close-download-window", () => {
    if (downloadWindow) {
        downloadWindow.close();
        downloadWindow = null;
    }
});

app.whenReady().then(createMainWindow);
app.on("window-all-closed", () => app.quit());
Menu.setApplicationMenu(null); // âœ… Completely removes the menu bar
